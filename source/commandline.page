<?xml version="1.0" encoding="utf-8"?>
<page xmlns="http://projectmallard.org/1.0/" type="topic" id="commandline">
  <info>
    <link type="guide" xref="index"/>
    <desc>Run jobs on powerful HBS Grid compute nodes from the terminal</desc>
    <credit type="author">
      <name>Ista Zahn, Â©President &amp; Fellows of Harvard College</name>
      <email>izahn@hbs.edu</email>
      <years>2020</years>
      <copyright>President &amp; Fellows of Harvard College.</copyright>
    </credit>
  </info>
  <links type="section"/>
  <title>Start Jobs from the Terminal</title>

  <p>The HBS Grid uses <link href="https://www.ibm.com/docs/en/spectrum-lsf">IBM Spectrum LSF</link> to run applications on powerful
  remote computers. <app>LSF</app> is a large and complex set of tools; our goal here is to give you just enough information so that you
  can use it to run jobs on our system, without overwhelming you with details and options.</p>

  <note style="tip">
    <p> Note: this software environment includes <link xref="menulaunch">robust graphical tools</link> that reduce the need to use the
    command line for many interactive tasks. This section is for those who prefer the command line, either for aesthetic reasons or because
    they need to submit <em>batch</em> jobs or carry out complex operations that cannot easily be performed using graphical menu-driven tools.</p>
  </note>
  
  <section id="overview">
    <title>Jobs submission basics</title>
    
    <p>LSF provides <cmd>bsub</cmd>, a command-line program for running applications on powerful remote computers. For example, you can use</p>
    <code>bsub -q short_int -Is R</code>
    <p>to start an interactive R job on a compute node. Breaking this example down will make
    the basics of <cmd>bsub</cmd> clear:</p>
    <list style = "compact">
      <item><p><cmd>bsub</cmd> (<em style="strong">b</em>atch <em style="strong">sub</em>mission) is the top-level command used to run applications on powerful remote machines.</p></item>
      <item><p><cmd> -q short_int</cmd> means you want to run on the <em> short interactive</em> queue (details below).</p></item>
      <item><p><cmd>-Is</cmd> means we are running an <em style="strong">I</em>nteractive <em style="strong">s</em>hell.</p></item>
      <item><p>The rest of the command (<cmd>R</cmd> in this case) is the command that will be run on the remote machine.</p></item>
    </list>

    <note style="tip">
      <p>When you first log in to the HBS Grid using <app>NoMachine</app> or <app>ssh</app> you are running on a <app>login node</app>.
      The login nodes <em>do not</em> have substantial CPU or RAM available; all computationally intensive processes should be run on
      the <app>compute nodes</app>. A diagram of the HBS Grid architecture helps make this clear:</p>
      <media type="image" src="images/griddiagram.png"/>
      <p>As this diagram shows, the primary purpose of the <app>login nodes</app> is to serve as a hub for launching jobs on powerful
      <app>compute nodes</app>. You can do that from the command line using <app>bsub</app> or from the desktop menu using
      application launchers.</p>

      <p>You may sometimes wish to run applications on the <app>login node</app>, and this is perfectly fine as long as you are not using
      it for computationally intensive work. For example, you may wish to run <cmd>python</cmd> to work out a small code example, or use
      <cmd>locate</cmd> to find a file you were working on. These low-resource activities can and should be done on the <app>login node</app>.
      The important thing to remember is that <cmd>bsub</cmd> is used to run commands on powerful compute nodes.</p>
    </note>
  </section>

  <section id="resources">
    <title>Resource requirements</title>

    <p>The <cmd>bsub</cmd> command allows you to specify <em>RAM</em> and <em>CPU</em> requirements for your job via the <cmd>-M</cmd> and <cmd>-n</cmd> arguments.
    For example, you can run a python job with 50 GB of RAM and 4 CPUs with</p>
    <code>bsub -q short_int -M 50G -n 4 -Is python</code>
    <p>Knowing just these three arguments to <cmd>bsub</cmd> will take you a long way. There is
    <link href="https://www.ibm.com/support/knowledgecenter/SSWRJV_10.1.0/lsf_command_ref/bsub.heading_options.1.html"> much more to know about bsub</link>,
    but these basics will get you started.</p>
  </section>

  <section id="queues">
    <title>Interactive and batch queue limits</title>

    <p>Machines on the HBS Grid are grouped in <em>queues</em> and <cmd>bsub</cmd> can start jobs in either <em>batch</em> (background) or
    <em>interactive</em> modes. Batch jobs make it easier to run many jobs at once and are more efficient because jobs don't keep running after
    the program is executed. Interactive jobs on the other hand tend to be more convenient, especially for exploratory work or when developing
    or debugging a script or program.</p>
    
    <p><em style="strong">Batch</em> queues like <em>short</em> and <em>long</em> are for running commands without interaction. For example</p>
    <code>bsub -q short Rscript my_r_code.R</code>
    <p>runs <file>my_r_code.R</file> in batch mode, and</p>
    <code>bsub -q short stata -b my_stata_code.do</code>
    <p>runs <file>my_stata_code.do</file> in batch mode.</p>
    
    <p><em style="strong">Interactive</em> queues like <em>short_int</em> and <em>long_int</em>  are used to run
    applications that you will interact with. For example,</p>
    <code>bsub -q short_int -Is rstudio</code>
    <p>runs an interactive <app>RStudio</app> application, and</p>
    <code>bsub -q short_int -Is xstata</code>
    <p>runs an interactive <app>stata</app> application.</p>

    <note style="tip">
      <p>The key differences when submitting batch vs interactive jobs are the <cmd>-q</cmd> and <cmd>-Is</cmd> arguments. For example we used
      <cmd>-q short</cmd>for batch and <cmd>-q short_int</cmd> for interactive. Interactive jobs must also include the <cmd>-Is</cmd> option.</p>
    </note>
    
    <p>Queues have other characteristics in addition to the batch vs. interactive distinction. These include the maximum run time and maximum number of CPUs
    that can be reserved per job. These queue-level limits are summarized in the table below.</p>

    <table frame="all" shade="rows">
      <tr><th><p>Queue          </p></th><th><p>Type                </p></th><th><p>Length  </p></th><th><p>Max Cores/Job</p></th></tr>
      <tr><td><p>long_int       </p></td><td><p>interactive         </p></td><td><p>3 days  </p></td><td><p>4            </p></td></tr>
      <tr><td><p>short_int      </p></td><td><p>interactive         </p></td><td><p>1 day   </p></td><td><p>12           </p></td></tr> 
      <tr><td><p>sas_int        </p></td><td><p>interactive         </p></td><td><p>no limit</p></td><td><p>4            </p></td></tr> 
      <tr><td><p>long           </p></td><td><p>batch               </p></td><td><p>7 days  </p></td><td><p>12           </p></td></tr> 
      <tr><td><p>short          </p></td><td><p>batch               </p></td><td><p>3 days  </p></td><td><p>16           </p></td></tr> 
      <tr><td><p>gpu            </p></td><td><p>interactive or batch</p></td><td><p>no limit</p></td><td><p>4            </p></td></tr> 
      <tr><td><p>sas            </p></td><td><p>batch               </p></td><td><p>no limit</p></td><td><p>4            </p></td></tr> 
      <tr><td><p>unlimited      </p></td><td><p>interactive or batch</p></td><td><p>no limit</p></td><td><p>4 (for now)  </p></td></tr> 
    </table>
  </section>
  
  <section id="sessions">
    <title>Software environments</title>

    <p>The available software environments contain a huge selection of graphical and terminal-based tools and are described in <link xref="environments"/>.
    For the most part you shouldn't need to do anything to install or configure these tools -- if there is some software you would like that we don't
    have please get in touch and we'll see if we can install and set it up for you.</p>

    <p>In order to facilitate reproducible research and analysis we preserve old software environments so that you can switch back to them later if needed.
    These older environments can be loaded using <link href="https://lmod.readthedocs.io/en/latest/010_user.html">Lmod</link>. Running <cmd>ml avail</cmd> will
    show you the available environments, named by date and version number.</p>

    <p>For example, suppose that you have a python project and that your <app>pandas</app> code no longer works with the latest <app>pandas</app> release in the current software
    environment. In that case you can revert to a previous software environment and run your analysis using an older version of <app>pandas</app>.</p>

    <p>You can use the <cmd>ml</cmd> command from the terminal to list, load, and unload Lmod environment, as shown below.</p>

    <screen>
      <input>ml avail</input>
      <output>
        -------------- /usr/local/app/rcs_bin/techpreview-dev/modulefiles --------------
        rcs/rcs_2020.01 (E)    rcs/rcs_2021.01 (E)    rcs/rcs_2021.03 (E,L,D)


        Where:
        D:  Default Module
        E:  Technology Preview
        L:  Module is loaded
        
        Use "module spider" to find all possible modules.
        Use "module keyword key1 key2 ..." to search for all possible modules matching
        any of the "keys".
      </output>
    </screen>
    
    <p>You can get information about specific software modules using the standard <cmd>ml</cmd> or <cmd>module</cmd> commands.</p>

    <screen>
      <input>module spyder rcs/rcs_2021.03</input>
      <output>
        ---------------------------------------------------------------------------
        rcs: rcs/rcs_2021.03
        ---------------------------------------------------------------------------
        Description:
        Conda environment for research computing
        
        Help:
        Sets up environment for Data Science and Statistical computing.
        
        A huge list of software is avalable, including 'python', 'spyder', 'R', 
        'rstudio', 'emacs', 'vscode', rclone, ripgrep, nnn and much more.
        
        Key software versions:
        
        libgcc-ng 9
        cudatoolkit 10.1
        tensorflow-gpu 2.2
        python 3.8
        jupyterlab 3.0
        numpy 1.20
        pandas 1.2
        r-base 4.0
        r-tidyverse 1.3
        sas 9.4
        stata 16
        octave 6.2
        mathematica 12
        matlab R2020a
        emacs 27.1
        QGIS 3.16
        
        For a detailed software list open a terminal and run 
        
        conda env export -n rcs_2021.03
      </output>
    </screen>
  </section>
</page>
